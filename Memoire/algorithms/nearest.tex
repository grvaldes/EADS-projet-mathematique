\DontPrintSemicolon
\KwIn{Matrice de distance (\texttt{distance[\,][\,]}), Liste de villes (\texttt{villes[\,]})}
\KwOut{Ordre de visite (\texttt{ordre\_visite}) et distance totale (\texttt{distance\_totale})}
\vspace{10pt}
\texttt{actuelle} $\gets$ indice ville départ\;
\texttt{visitee[\,]} $\gets$ liste de booleans False pour chaque ville\;
\texttt{ordre\_visite[0]} $\gets$ actuelle\;
\texttt{visitee[actuelle]} $\gets$ \texttt{True}\;
\texttt{distance\_totale} $\gets 0$\;

\vspace{10pt}
\While{il reste de villes à visiter}{
    \texttt{meilleur\_distance} $\gets \infty$\;
    \texttt{meilleur\_voisin} $\gets$ \texttt{None}\;
    
    \vspace{10pt}
    \ForEach{voisin $v$ et sa distance $d$ de la ville actuelle}{
        \If{voisin pas visité \textbf{et} distance < meilleur\_distance}{
            \texttt{meilleur\_distance} $\gets$ distance[actuelle][v]\;
            \texttt{meilleur\_voisin} $\gets v$\;
        }
    }

    \vspace{10pt}
    \If{il n'y a pas de meilleur voisin}{
        \textbf{break}
    }
    
    \vspace{10pt}
    \texttt{actuelle} $\gets$ indice du meilleur voisin\;
    \texttt{visitee[actuelle]} $\gets$ \texttt{True}\;
    \texttt{ordre\_visite}$\gets$ ajouter ville actuelle\;
    \texttt{distance\_totale} $\gets$ \texttt{distance\_totale} + \texttt{meilleur\_distance}\;
}

\vspace{10pt}
\ForEach{ville visitée $v$ en ordre inverse}{
  \If {distance avec ville de départ > 0}{
    \texttt{ordre\_visite}$\gets$ ajouter ville de départ\;
    \texttt{distance\_totale} $\gets$ \texttt{distance\_totale} + \texttt{distance[v][depart]}\;
    \texttt{actuelle} $\gets$ indice du ville de départ\;
  } \Else {
    \texttt{ordre\_visite}$\gets$ ajouter ville antérieure\;
    \texttt{distance\_totale} $\gets$ \texttt{distance\_totale} + \texttt{distance[v][v-1]}\;
    \texttt{actuelle} $\gets$ indice du ville de antérieure\;
  }
}

\vspace{10pt}
\Return \texttt{ordre\_visite}, \texttt{distance\_totale}\;
\caption{Algorithme pour les voisins plus proches}